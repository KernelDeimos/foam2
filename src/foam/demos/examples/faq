## FAQ

##  Q1
Where can I find built-in constants?
ex)
print("Method CODE property constant:", foam.core.Method.CODE);
foam.core.Method.CODE.describe;

Answer: Property constants are copied out of the model into to resulting class and prototype.
Example:
--
foam.CLASS({
  name: 'Test',
  properties: [ 'p1', 'p2' ]
});

print(Test.P1.name, Test.P2.name);

var t = Test.create();
print(t.P1.name, t.P2.name);

##  Q2
Is class is a kind of type?

Answer:
A class is a class in the conventional OO sense.
When you create a foam.CLASS(), it will define a new class.
When you see something like { class: 'some.package.Name' , a: 1, b: 2 }, it will create
an object of class 'some.package.Name' with the property a set to 1 and b to 2.
It would be the equivalent to some.package.Name.create({a: 1, b: 2}).
FOAM extends the regular JSON syntax to support objects by creating classes by
specifying their class.
Ex.:
--
foam.CLASS({
  package: 'some.package2',
  name: 'Test',
  properties: [ 'p1', 'p2' ]
});

var p = foam.json.parse({class: 'some.package2.Test', p1: 42, p2: 'John'});
print(p.cls_.id);

##  Q3
Is the Package Interface and how to use this in Foam?

Answer: A classes package is defined with package: and is optional.
--
// Without a package:

foam.CLASS({
  name: 'Test',
  properties: [ 'p1', 'p2' ]
});

print(Test.create());

// With a package:

foam.CLASS({
  package: 'some.package2',
  name: 'Test',
  properties: [ 'p1', 'p2' ]
});

print(some.package2.Test.create());

// When used from another class, packaged classes can be required:

foam.CLASS({
  name: 'Client',
  requires: [ 'some.package2.Test' ],
  methods: [
    function createTest() { return this.Test.create(); }
  ]
});

print(Client.create().createTest());

##  Q4
What are all of the types in FOAM?
Answer:
In FOAM, "types" are just sub-classes of foam.core.Property.
Most of the types in FOAM are defined in foam/core/types.js.
Types are not hard-coded into FOAM and you can create your own by extending Property.
The following script will find all of the FOAM "types":
--
for ( var v in foam.USED ) { try { if ( foam.core.Property.isSubClass(foam.lookup(v, true)) ) print(v); } catch(x) {} }
for ( var v in foam.UNUSED ) { try { if ( foam.core.Property.isSubClass(foam.lookup(v, true)) ) print(v); } catch(x) {} }

##  Q5
What does this code mean? e.g., flags: [&#39;java&#39;], flags[&#39;web&#39;] , flags: [ &#39;node&#39; ]
<br>
<br>
<b>A:</b> Some FOAM models are intended only for specific platforms, and the flags feature
determines when and where a model will be loaded or ignored.
For example, view specific models are only needed when loaded in a web browser,
so they can be configured with <code>flags: ['web']</code>.
Other code may only be useful when run in node.js <code>flags: ['node']</code>, for java <code>flags: ['java']</code>,
or swift, <code>flags: ['swift']</code>. When <code>flags: ['debug']</code> is present, the model is only
loaded when in debug mode (which is the default).
<br>
In your HTML file, you can customize the flags by setting FOAM_FLAGS before loading foam:
<pre>
  &lt;script>FOAM_FLAGS = {debug: false};&lt;/script>
  &lt;script language="javascript" src="../../../foam.js">&lt;/script>
</pre>
The set of flags isn't fixed, and you can make up your own for your own purposes.

##  Q6
How do I use References?
<br>
<br>
A Reference is a type of property which stores the primary key of a record
stored in a DAO.
<br>
To create a Reference property, set its class: 'Reference', and then set the of: property to be the model
of the referenced class, and daoKey: to be the context key of the referenced DAO.
<br>
Relationships with cardinality: '1:*' will add a Reference property to the target model.
--

foam.CLASS({
  name: 'Province',

  properties: [ 'id', 'name' ],

  methods: [
    function toSummary() { return this.name; }
  ]
});

foam.CLASS({
  name: 'ReferenceTest',

  requires: [
    'foam.dao.EasyDAO',
    'foam.u2.view.ReferenceView'
   ],

  properties: [
    {
      name: 'provinceDAO',
      hidden: true,
      factory: function() {
        return this.EasyDAO.create({
          of: Province,
          daoType: 'MDAO',
          testData: [
            { id: 'ON', name: 'Ontario' },
            { id: 'PQ', name: 'Quebec' },
            { id: 'NS', name: 'Nova Scotia' },
            { id: 'NB', name: 'New Brunswick' },
            { id: 'PE', name: 'Prince Edward Island' }
            // that's enough for demo purposes
          ]
        });
      }
    },
    {
      class: 'Reference',
      name: 'province1',
      of: 'Province',
      targetDAOKey: 'provinceDAO'

      // Without specifying the view:, this property will use a ReferenceView
      // which displays the result of calling the toSummary() method
      // for each object from the DAO.
    },
    {
      class: 'Reference',
      of: 'Province',
      name: 'province2',
      targetDAOKey: 'provinceDAO',
      view: { class: 'foam.u2.view.ReferenceView', objToChoice: function(obj) { return [obj.id, obj.id + ' ' + obj.name]; } }
      // In this case, we want to change what's displayed in the ReferenceView,
      // so we explicitly set the view: and then override objToChoice: to
      // also include the province id.
    }
  ]
});
add('output');
var rt = ReferenceTest.create({province1: 'ON', province2: 'PQ'});
add(rt);

rt.province1$dao.select(console);

// Each reference property has an associated $dao property
// which returns the referenced DAO.
add('select: ').start().style({'margin-left': '12px'}).select(rt.province1$dao, function(p) {
  return this.E().add(p.name);
}).end().br();

// Each reference property has an associated $find property
// which returns a promise which will lookup the referenced
// object from its DAO.

rt.province1$find.then(function(p) {
  add('find province1: ', p.name);
});

rt.province2$find.then(function(p) {
  add('find province2: ', p.name);
});

// We can also, just add promises to U2 directly?
add('find: ').add(rt.province1$find);
